################################################################################
#
# Script that presents and tests a function that performs an LRT to two
# models that are fitted to datasets generated by multiple imputation
# and provides a test statistic per Meng and Rubin (1992)
#
# The parallel version will not work on Windows machines because of the use of
# Unix-alike specific parallel code.
#
# Andrew Robinson 15-April-2015
#
################################################################################

library(lme4)    # For mixed-effects models

library(Amelia)  # For imputation

library(equivalence) # For data that I know

library(parallel) # Speed things up

library(compiler) # A different speed-up

data(ufc)

str(ufc)

ufc <- subset(ufc, !is.na(Dbh))
ufc$Species[ufc$Species %in% c("F","FG")] <- "GF"
ufc$Species <- factor(ufc$Species)
ufc$ht.measured <- is.na(ufc$Height)

ufc <- subset(ufc,
              Species %in% names(sort(-table(Species)))[1:6],
              select = c("ht.measured","Plot","Dbh.in","Species"))

## Fit a pair of models to compare using LRT

ufc.whole <- ufc

isna.1.w <- glmer(ht.measured ~ Dbh.in + Species + (1 | Plot),
                  data = ufc.whole, family = binomial)
isna.0.w <- glmer(ht.measured ~ Dbh.in + (1 | Plot),
                  data = ufc.whole, family = binomial)

anova(isna.0.w, isna.1.w)

## Make some data missing - 5% each of Dbh, Species, and the response.

make.missing <- sample(1:nrow(ufc), size = 90, replace = FALSE)

is.na(ufc$Species[make.missing[1:30]]) <- TRUE
is.na(ufc$Dbh.in[make.missing[31:60]]) <- TRUE
is.na(ufc$ht.measured[make.missing[61:90]]) <- TRUE

## Impute datasets using Amelia

ufc.imputes <- amelia(ufc,
                      m = 5,
                      cs = "Plot",
                      noms = "Species")

names(ufc.imputes)

str(ufc.imputes$imputations)

## Fit models to each instance

ufc.models <- mclapply(ufc.imputes$imputations,
                       function (dataset) {
                         glmer(ht.measured ~ Dbh.in + Species + (1 | Plot),
                               data = dataset, family = binomial)
                       },
                       mc.cores = 4)

## Obtain average model parameters

ufc.par.hat <-
  do.call(rbind, lapply(ufc.models,
                        function (fit) {
                          c(getME(fit, "theta"), fixef(fit))
                        }))

ufc.par.hat <- colMeans(ufc.par.hat)

## Create deviance functions for each imputation

ufc.dev.funs <- mclapply(ufc.imputes$imputations,
                         function (dataset) {
                           glmer(ht.measured ~ Dbh.in + Species + (1 | Plot),
                                 data = dataset, family = binomial,
                                 devFunOnly = TRUE)
                         },
                       mc.cores = 4)

## Evaluate the deviance for each refitted model at these estimates

(ufc.dev <- sapply(ufc.dev.funs, function(devfun) devfun(ufc.par.hat)))

################################################################################

###  Ok, now develop an LRT function using these pieces.

imputeLRT.p <- function(h0, h1, imputed.data.list, mc.cores = 4) {
  m <- length(imputed.data.list)
  h0.models <- mclapply(imputed.data.list,
                        function (dataset) {
                          update(h0, data = dataset)
                        },
                        mc.cores = mc.cores)
  h0.dev.funs <- mclapply(imputed.data.list,
                          function (dataset) {
                            update(h0, data = dataset,
                                   devFunOnly = TRUE)
                          },
                          mc.cores = mc.cores)
  Q.bar.0 <-
    colMeans(do.call(rbind,
                     lapply(h0.models,
                            function (fit) {
                              c(getME(fit, "theta"), fixef(fit))
                            })))
  h1.models <- mclapply(imputed.data.list,
                        function (dataset) {
                          update(h1, data = dataset)
                        },
                        mc.cores = mc.cores)
  h1.dev.funs <- mclapply(imputed.data.list,
                          function (dataset) {
                            update(h1, data = dataset,
                                   devFunOnly = TRUE)
                          },
                          mc.cores = mc.cores)
  Q.bar.1 <-
    colMeans(do.call(rbind,
                     lapply(h1.models,
                            function (fit) {
                              c(getME(fit, "theta"), fixef(fit))
                            })))
  d.prime.m.bar <- mean(unlist(mclapply(1:m,
                                        function(i) {
                                          anova(h0.models[[i]],
                                                h1.models[[i]])$Chisq[2]
                                        },
                                        mc.cores = mc.cores)))
  d.L.bar <- mean(unlist(mclapply(1:m,
                                  function(i) {
                                    h0.dev.funs[[i]](Q.bar.0) -
                                      h1.dev.funs[[i]](Q.bar.1)
                                  },
                                  mc.cores = mc.cores)))
  p0 <- length(Q.bar.0)
  p1 <- length(Q.bar.1)
  k <- p1 - p0
  rL <- (m + 1) / ((m - 1) * k) * (d.prime.m.bar - d.L.bar) # 3.8
  D.L <- d.L.bar / ((1 + rL) * k)                           # 3.7
  v <- k * (m - 1)
  w <- ifelse(v > 4,                                        # 2.7
              4 + (v - 4) * (1 + (1 - v/2) / rL)^2,
              v / 2 * (1 + 1/k) * (1 + 1/rL)^2)
  Pval <- 1 - pf(D.L, k, w)
  return(list(
    D.L = D.L,
    Pval = Pval,
    rL = rL,
    d.L.bar = d.L.bar,
    d.prime.m.bar = d.prime.m.bar,
    Q.bar.0 = Q.bar.0,
    Q.bar.1 = Q.bar.1,
    k = k,
    w = w,
    p0 = p0,
    p1 = p1,
    m = m))
}


## Here's a test

isna.1 <- glmer(ht.measured ~ Dbh.in + Species + (1 | Plot),
                data = ufc, family = binomial)
isna.0 <- glmer(ht.measured ~ Dbh.in + (1 | Plot),
                data = ufc, family = binomial)

imputeLRT.p(isna.0, isna.1,
          list(ufc.whole, ufc.whole, ufc.whole, ufc.whole, ufc.whole))

## P-value should be comparable to

anova(isna.0.w, isna.1.w)

## Now apply to missing data cases

ufc.imputes.V <- amelia(ufc,
                        m = 5,
                        cs = "Plot",
                        noms = "Species")

imputeLRT.p(isna.0, isna.1, ufc.imputes.V$imputations)



ufc.imputes.X <- amelia(ufc,
                        m = 10,
                        cs = "Plot",
                        noms = "Species")

imputeLRT.p(isna.0, isna.1, ufc.imputes.X$imputations)



ufc.imputes.XX <- amelia(ufc,
                        m = 20,
                        cs = "Plot",
                        noms = "Species")

imputeLRT.p(isna.0, isna.1, ufc.imputes.XX$imputations)



ufc.imputes.L <- amelia(ufc,
                        m = 50,
                        cs = "Plot",
                        noms = "Species")

imputeLRT.p(isna.0, isna.1, ufc.imputes.L$imputations)


##  A version that should work more broadly

imputeLRT <- function(h0, h1, imputed.data.list) {
  m <- length(imputed.data.list)
  h0.models <- lapply(imputed.data.list,
                      function (dataset) {
                        update(h0, data = dataset)
                      })
  h0.dev.funs <- lapply(imputed.data.list,
                        function (dataset) {
                          update(h0, data = dataset,
                                 devFunOnly = TRUE)
                        })
  Q.bar.0 <-
    colMeans(do.call(rbind,
                     lapply(h0.models,
                            function (fit) {
                              c(getME(fit, "theta"), fixef(fit))
                            })))
  h1.models <- lapply(imputed.data.list,
                      function (dataset) {
                        update(h1, data = dataset)
                      })
  h1.dev.funs <- lapply(imputed.data.list,
                        function (dataset) {
                          update(h1, data = dataset,
                                 devFunOnly = TRUE)
                        })
  Q.bar.1 <-
    colMeans(do.call(rbind,
                     lapply(h1.models,
                            function (fit) {
                              c(getME(fit, "theta"), fixef(fit))
                            })))
  d.prime.m.bar <- mean(unlist(lapply(1:m,
                                      function(i) {
                                        anova(h0.models[[i]],
                                              h1.models[[i]])$Chisq[2]
                                      })))
  d.L.bar <- mean(unlist(lapply(1:m,
                                function(i) {
                                  h0.dev.funs[[i]](Q.bar.0) -
                                    h1.dev.funs[[i]](Q.bar.1)
                                })))
  p0 <- length(Q.bar.0)
  p1 <- length(Q.bar.1)
  k <- p1 - p0
  rL <- (m + 1) / ((m - 1) * k) * (d.prime.m.bar - d.L.bar) # 3.8
  D.L <- d.L.bar / ((1 + rL) * k)                           # 3.7
  v <- k * (m - 1)
  w <- ifelse(v > 4,                                        # 2.7
              4 + (v - 4) * (1 + (1 - v/2) / rL)^2,
              v / 2 * (1 + 1/k) * (1 + 1/rL)^2)
  Pval <- 1 - pf(D.L, k, w)
  return(list(
    D.L = D.L,
    Pval = Pval,
    rL = rL,
    d.L.bar = d.L.bar,
    d.prime.m.bar = d.prime.m.bar,
    Q.bar.0 = Q.bar.0,
    Q.bar.1 = Q.bar.1,
    k = k,
    w = w,
    p0 = p0,
    p1 = p1,
    m = m))
}

imputeLRT(isna.0, isna.1,
          list(ufc.whole, ufc.whole, ufc.whole, ufc.whole, ufc.whole))

imputeLRT(isna.0, isna.1, ufc.imputes.X$imputations)




imputeLRT.pw <- function(h0, h1, imputed.data.list, mc.cores = 4) {
#    browser()
    my.cluster <- makeCluster(mc.cores)
    clusterExport(my.cluster,
                  c("h0","h1","imputed.data.list"),
                  environment())
    m <- length(imputed.data.list)
    h0.models <- clusterApplyLB(my.cluster,
                                imputed.data.list,
                                function (dataset) {
                                    require(lme4)
                                    update(h0, data = dataset)
                                })
    h0.dev.funs <- clusterApplyLB(my.cluster,
                                  imputed.data.list,
                                  function (dataset) {
                                      update(h0, data = dataset,
                                             devFunOnly = TRUE)
                                  })
    Q.bar.0 <-
        colMeans(do.call(rbind,
                         lapply(h0.models,
                                function (fit) {
                                    c(getME(fit, "theta"), fixef(fit))
                                })))
    h1.models <- clusterApplyLB(my.cluster,
                                imputed.data.list,
                                function (dataset) {
                                    update(h1, data = dataset)
                                })
    h1.dev.funs <- clusterApplyLB(my.cluster,
                                  imputed.data.list,
                                  function (dataset) {
                                      update(h1, data = dataset,
                                             devFunOnly = TRUE)
                                  })
    Q.bar.1 <-
        colMeans(do.call(rbind,
                         lapply(h1.models,
                                function (fit) {
                                    c(getME(fit, "theta"), fixef(fit))
                                })))
    d.prime.m.bar <- mean(unlist(clusterApplyLB(my.cluster,
                                                1:m,
                                                function(i) {
                                                    anova(h0.models[[i]],
                                                          h1.models[[i]])$Chisq[2]
                                                })))
    d.L.bar <- mean(unlist(clusterApplyLB(my.cluster,
                                          1:m,
                                          function(i) {
                                              h0.dev.funs[[i]](Q.bar.0) -
                                                  h1.dev.funs[[i]](Q.bar.1)
                                          })))
    stopCluster(my.cluster)
    p0 <- length(Q.bar.0)
    p1 <- length(Q.bar.1)
    k <- p1 - p0
    rL <- (m + 1) / ((m - 1) * k) * (d.prime.m.bar - d.L.bar) # 3.8
    D.L <- d.L.bar / ((1 + rL) * k)                           # 3.7
    v <- k * (m - 1)
    w <- ifelse(v > 4,                                        # 2.7
                4 + (v - 4) * (1 + (1 - v/2) / rL)^2,
                v / 2 * (1 + 1/k) * (1 + 1/rL)^2)
    Pval <- 1 - pf(D.L, k, w)
    return(list(
        D.L = D.L,
        Pval = Pval,
        rL = rL,
        d.L.bar = d.L.bar,
        d.prime.m.bar = d.prime.m.bar,
        Q.bar.0 = Q.bar.0,
        Q.bar.1 = Q.bar.1,
        k = k,
        w = w,
        p0 = p0,
        p1 = p1,
        m = m))
}

imputeLRT.pw(isna.0, isna.1,
             list(ufc.whole, ufc.whole, ufc.whole, ufc.whole, ufc.whole))

imputeLRT.pw(isna.0, isna.1, ufc.imputes.X$imputations)

########

## Timing test

system.time(imputeLRT(isna.0, isna.1, ufc.imputes.XX$imputations))

system.time(imputeLRT.p(isna.0, isna.1, ufc.imputes.XX$imputations))

# system.time(imputeLRT.pw(isna.0, isna.1, ufc.imputes.XX$imputations))

imputeLRT.c <- cmpfun(imputeLRT)

system.time(imputeLRT.c(isna.0, isna.1, ufc.imputes.XX$imputations))

